/**
 * PR Orchestrator Module
 * Manages pull request creation and CI feedback processing
 */

import { Octokit } from '@octokit/rest';
import { PatchPlan } from '../patch-generator/patch-generator';

export interface PRCreationResult {
  prNumber: number;
  prUrl: string;
  branch: string;
  status: 'created' | 'failed';
  message?: string;
}

export interface CIFeedback {
  prNumber: number;
  checkRuns: CheckRun[];
  overallStatus: 'pending' | 'success' | 'failure';
  requiresAction: boolean;
  suggestedFixes?: string[];
}

export interface CheckRun {
  name: string;
  status: 'queued' | 'in_progress' | 'completed';
  conclusion?: 'success' | 'failure' | 'neutral' | 'cancelled' | 'timed_out';
  output?: {
    title: string;
    summary: string;
  };
}

export class PROrchestrator {
  private octokit: Octokit;

  constructor(githubToken: string) {
    this.octokit = new Octokit({ auth: githubToken });
  }

  /**
   * Create a pull request from a patch plan
   */
  async createPullRequest(
    owner: string,
    repo: string,
    patchPlan: PatchPlan,
    baseBranch: string = 'main'
  ): Promise<PRCreationResult> {
    try {
      // Create pull request
      const prTitle = this.generatePRTitle(patchPlan);
      const prBody = this.generatePRBody(patchPlan);

      const { data: pr } = await this.octokit.pulls.create({
        owner,
        repo,
        title: prTitle,
        body: prBody,
        head: patchPlan.targetBranch,
        base: baseBranch,
      });

      // Add labels
      await this.addLabels(owner, repo, pr.number, patchPlan);

      return {
        prNumber: pr.number,
        prUrl: pr.html_url,
        branch: patchPlan.targetBranch,
        status: 'created',
        message: 'Pull request created successfully',
      };
    } catch (error) {
      return {
        prNumber: 0,
        prUrl: '',
        branch: patchPlan.targetBranch,
        status: 'failed',
        message: `Failed to create PR: ${error}`,
      };
    }
  }

  /**
   * Process CI feedback and determine next actions
   */
  async processCIFeedback(
    owner: string,
    repo: string,
    prNumber: number
  ): Promise<CIFeedback> {
    const checkRuns = await this.getCheckRuns(owner, repo, prNumber);
    const overallStatus = this.determineOverallStatus(checkRuns);
    const requiresAction = overallStatus === 'failure';
    const suggestedFixes = this.analyzeFailed

CheckRuns(checkRuns);

    return {
      prNumber,
      checkRuns,
      overallStatus,
      requiresAction,
      suggestedFixes: requiresAction ? suggestedFixes : undefined,
    };
  }

  /**
   * Update PR based on CI feedback
   */
  async updatePRBasedOnFeedback(
    owner: string,
    repo: string,
    prNumber: number,
    feedback: CIFeedback
  ): Promise<void> {
    if (!feedback.requiresAction) {
      return;
    }

    // Add comment with suggested fixes
    if (feedback.suggestedFixes && feedback.suggestedFixes.length > 0) {
      const comment = this.generateFeedbackComment(feedback);
      await this.octokit.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: comment,
      });
    }
  }

  /**
   * Merge pull request when CI passes
   */
  async mergePullRequest(
    owner: string,
    repo: string,
    prNumber: number
  ): Promise<boolean> {
    try {
      await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number: prNumber,
        merge_method: 'squash',
      });
      return true;
    } catch (error) {
      console.error(`Failed to merge PR #${prNumber}:`, error);
      return false;
    }
  }

  private generatePRTitle(patchPlan: PatchPlan): string {
    return `Fix issue #${patchPlan.issueNumber}`;
  }

  private generatePRBody(patchPlan: PatchPlan): string {
    return `## Automated Fix for Issue #${patchPlan.issueNumber}

### Changes
${patchPlan.changes.map(c => `- ${c.changeType}: ${c.filePath} - ${c.description}`).join('\n')}

### Test Strategy
${patchPlan.testStrategy}

### Files Affected
- ${patchPlan.filesAffected.join('\n- ')}

---
*This pull request was automatically generated by AFU-9 CodeFactory Control*
`;
  }

  private async addLabels(
    owner: string,
    repo: string,
    prNumber: number,
    patchPlan: PatchPlan
  ): Promise<void> {
    const labels = ['automated', 'afu-9'];
    
    try {
      await this.octokit.issues.addLabels({
        owner,
        repo,
        issue_number: prNumber,
        labels,
      });
    } catch (error) {
      console.error('Failed to add labels:', error);
    }
  }

  private async getCheckRuns(
    owner: string,
    repo: string,
    prNumber: number
  ): Promise<CheckRun[]> {
    try {
      const { data: pr } = await this.octokit.pulls.get({
        owner,
        repo,
        pull_number: prNumber,
      });

      const { data: checkRuns } = await this.octokit.checks.listForRef({
        owner,
        repo,
        ref: pr.head.sha,
      });

      return checkRuns.check_runs.map(run => ({
        name: run.name,
        status: run.status as CheckRun['status'],
        conclusion: run.conclusion as CheckRun['conclusion'],
        output: run.output ? {
          title: run.output.title || '',
          summary: run.output.summary || '',
        } : undefined,
      }));
    } catch (error) {
      console.error('Failed to get check runs:', error);
      return [];
    }
  }

  private determineOverallStatus(checkRuns: CheckRun[]): 'pending' | 'success' | 'failure' {
    if (checkRuns.length === 0) {
      return 'pending';
    }

    const hasFailure = checkRuns.some(run => run.conclusion === 'failure');
    if (hasFailure) {
      return 'failure';
    }

    const allCompleted = checkRuns.every(run => run.status === 'completed');
    const allSuccess = checkRuns.every(run => run.conclusion === 'success');

    if (allCompleted && allSuccess) {
      return 'success';
    }

    return 'pending';
  }

  private analyzeFailedCheckRuns(checkRuns: CheckRun[]): string[] {
    const fixes: string[] = [];

    checkRuns
      .filter(run => run.conclusion === 'failure')
      .forEach(run => {
        if (run.name.toLowerCase().includes('lint')) {
          fixes.push('Run linter and fix code style issues');
        } else if (run.name.toLowerCase().includes('test')) {
          fixes.push('Fix failing tests or update test expectations');
        } else if (run.name.toLowerCase().includes('build')) {
          fixes.push('Fix build errors and type issues');
        } else {
          fixes.push(`Investigate and fix: ${run.name}`);
        }
      });

    return [...new Set(fixes)]; // Remove duplicates
  }

  private generateFeedbackComment(feedback: CIFeedback): string {
    return `## CI Feedback - Action Required

The automated checks have identified issues that need attention:

${feedback.suggestedFixes?.map(fix => `- [ ] ${fix}`).join('\n')}

Please review the check details above and apply the necessary fixes.

---
*Automated feedback from AFU-9 CodeFactory Control*
`;
  }
}
