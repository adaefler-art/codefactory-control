import { Octokit } from "octokit";
import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import { getGithubSecrets } from "../../lib/utils/secrets";
import { LambdaLogger } from "./logger";

const logger = new LambdaLogger('afu9-pr-creator');

interface PatchState {
  repo: string;
  targetBranch: string;
  patch: {
    description: string;
    branchName: string;
    files: Array<{
      path: string;
      content: string;
    }>;
  };
  issue?: {
    number: number;
    title: string;
    body: string;
  } | null;
}

export const handler = async (event: PatchState) => {
  logger.info("AFU-9 PRCreator started", { 
    repo: event.repo,
    targetBranch: event.targetBranch,
    branchName: event.patch.branchName,
    issueNumber: event.issue?.number 
  });

  // Load GitHub secrets from AWS Secrets Manager or environment
  const githubSecrets = await getGithubSecrets();
  const GITHUB_TOKEN = githubSecrets.token;

  // Validate required credentials
  if (!GITHUB_TOKEN) {
    logger.error("GitHub token not found in secrets");
    throw new Error("Configuration error: GitHub token is not configured");
  }

  const [owner, repo] = event.repo.split("/");
  
  if (!owner || !repo || event.repo.split("/").length !== 2) {
    logger.error("Invalid repo format", undefined, { repo: event.repo });
    throw new Error(`Invalid repo format: ${event.repo}. Expected format: owner/repo`);
  }

  let workdir: string | null = null;

  try {
    const octokit = new Octokit({ auth: GITHUB_TOKEN });

    workdir = fs.mkdtempSync(path.join(os.tmpdir(), "afu9-"));
    logger.debug("Working directory created", { workdir });

    logger.info("Cloning repository", { owner, repo });
    try {
      execSync(`git clone https://github.com/${owner}/${repo}.git .`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      logger.error("Failed to clone repository", error, { owner, repo });
      throw new Error(`Failed to clone repository ${owner}/${repo}`);
    }

    logger.info("Checking out target branch", { branch: event.targetBranch });
    try {
      execSync(`git checkout ${event.targetBranch}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      logger.error("Failed to checkout target branch", error, { 
        branch: event.targetBranch 
      });
      throw new Error(`Failed to checkout branch ${event.targetBranch}`);
    }

    const branchName = event.patch.branchName;
    logger.info("Creating new branch", { branchName });
    try {
      execSync(`git checkout -b ${branchName}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      logger.error("Failed to create branch", error, { branchName });
      throw new Error(`Failed to create branch ${branchName}`);
    }

    logger.info("Writing patch files", { 
      fileCount: event.patch.files.length 
    });
    for (const file of event.patch.files) {
      const filePath = path.join(workdir, file.path);
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, file.content, "utf8");
    }

    try {
      execSync(`git add .`, { cwd: workdir, stdio: "inherit" });
      execSync(`git commit -m "AFU-9 v0.1: autogenerated patch"`, {
        cwd: workdir,
        stdio: "inherit"
      });
      logger.info("Pushing branch to remote", { branchName });
      execSync(`git push origin ${branchName}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      logger.error("Failed to commit and push changes", error);
      throw new Error("Failed to commit and push changes");
    }

    const prTitle = event.issue
      ? `AFU-9: Fix for Issue #${event.issue.number} (v0.1 stub)`
      : `AFU-9: Autogenerated Patch (v0.1 stub)`;

    const prBody =
      (event.issue
        ? `Bezug auf Issue #${event.issue.number}: ${event.issue.title}\n\n`
        : `Manuell ausgelöster AFU-9 v0.1 Job.\n\n`) +
      `Beschreibung:\n${event.patch.description}\n\n` +
      `Hinweis: v0.1 ist ein Walking Skeleton und generiert nur einfache Änderungen.`;

    logger.info("Creating pull request", { 
      title: prTitle,
      head: branchName,
      base: event.targetBranch 
    });
    try {
      const { data: pr } = await octokit.rest.pulls.create({
        owner,
        repo,
        title: prTitle,
        head: branchName,
        base: event.targetBranch,
        body: prBody
      });

      logger.info("Pull request created successfully", { 
        prNumber: pr.number,
        prUrl: pr.html_url 
      });

      return {
        ...event,
        prUrl: pr.html_url,
        prNumber: pr.number
      };
    } catch (error) {
      logger.error("Failed to create pull request", error, {
        branch: branchName,
        base: event.targetBranch,
      });
      
      // Check for duplicate PR by looking at error details
      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();
        if (errorMsg.includes("validation failed") || 
            errorMsg.includes("pull request already exists") ||
            errorMsg.includes("a pull request already exists")) {
          throw new Error(`Failed to create PR: A pull request already exists for ${branchName}`);
        }
      }
      
      throw new Error("Failed to create pull request");
    }
  } catch (error) {
    logger.error("Error in PRCreator", error, {
      repo: event.repo,
      branchName: event.patch.branchName,
      issueNumber: event.issue?.number
    });
    throw error;
  } finally {
    // Clean up working directory
    if (workdir && fs.existsSync(workdir)) {
      try {
        fs.rmSync(workdir, { recursive: true, force: true });
        logger.debug("Cleaned up working directory", { workdir });
      } catch (cleanupError) {
        logger.warn("Failed to clean up working directory", { 
          workdir 
        });
      }
    }
  }
};
