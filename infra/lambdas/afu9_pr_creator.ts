import { Octokit } from "octokit";
import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";

const GITHUB_TOKEN = process.env.AFU9_GITHUB_TOKEN;

interface PatchState {
  repo: string;
  targetBranch: string;
  patch: {
    description: string;
    branchName: string;
    files: Array<{
      path: string;
      content: string;
    }>;
  };
  issue?: {
    number: number;
    title: string;
    body: string;
  } | null;
}

export const handler = async (event: PatchState) => {
  console.log("AFU-9 PRCreator v0.1", { event });

  // Validate required environment variables
  if (!GITHUB_TOKEN) {
    console.error("AFU9_GITHUB_TOKEN environment variable is not configured");
    throw new Error("Configuration error: AFU9_GITHUB_TOKEN is not set");
  }

  const [owner, repo] = event.repo.split("/");
  
  if (!owner || !repo || event.repo.split("/").length !== 2) {
    console.error("Invalid repo format", { repo: event.repo });
    throw new Error(`Invalid repo format: ${event.repo}. Expected format: owner/repo`);
  }

  let workdir: string | null = null;

  try {
    const octokit = new Octokit({ auth: GITHUB_TOKEN });

    workdir = fs.mkdtempSync(path.join(os.tmpdir(), "afu9-"));
    console.log("Working directory:", workdir);

    console.log(`Cloning repository ${owner}/${repo}...`);
    try {
      execSync(`git clone https://github.com/${owner}/${repo}.git .`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      console.error("Error cloning repository:", {
        error: error instanceof Error ? error.message : String(error),
        repo: `${owner}/${repo}`,
      });
      throw new Error(`Failed to clone repository ${owner}/${repo}`);
    }

    console.log(`Checking out branch ${event.targetBranch}...`);
    try {
      execSync(`git checkout ${event.targetBranch}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      console.error("Error checking out target branch:", {
        error: error instanceof Error ? error.message : String(error),
        branch: event.targetBranch,
      });
      throw new Error(`Failed to checkout branch ${event.targetBranch}`);
    }

    const branchName = event.patch.branchName;
    console.log(`Creating new branch ${branchName}...`);
    try {
      execSync(`git checkout -b ${branchName}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      console.error("Error creating new branch:", {
        error: error instanceof Error ? error.message : String(error),
        branch: branchName,
      });
      throw new Error(`Failed to create branch ${branchName}`);
    }

    console.log("Writing patch files...");
    for (const file of event.patch.files) {
      const filePath = path.join(workdir, file.path);
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, file.content, "utf8");
    }

    try {
      execSync(`git add .`, { cwd: workdir, stdio: "inherit" });
      execSync(`git commit -m "AFU-9 v0.1: autogenerated patch"`, {
        cwd: workdir,
        stdio: "inherit"
      });
      console.log("Pushing branch to remote...");
      execSync(`git push origin ${branchName}`, {
        cwd: workdir,
        stdio: "inherit"
      });
    } catch (error) {
      console.error("Error committing and pushing changes:", {
        error: error instanceof Error ? error.message : String(error),
      });
      throw new Error("Failed to commit and push changes");
    }

    const prTitle = event.issue
      ? `AFU-9: Fix for Issue #${event.issue.number} (v0.1 stub)`
      : `AFU-9: Autogenerated Patch (v0.1 stub)`;

    const prBody =
      (event.issue
        ? `Bezug auf Issue #${event.issue.number}: ${event.issue.title}\n\n`
        : `Manuell ausgelöster AFU-9 v0.1 Job.\n\n`) +
      `Beschreibung:\n${event.patch.description}\n\n` +
      `Hinweis: v0.1 ist ein Walking Skeleton und generiert nur einfache Änderungen.`;

    console.log("Creating pull request...");
    try {
      const { data: pr } = await octokit.rest.pulls.create({
        owner,
        repo,
        title: prTitle,
        head: branchName,
        base: event.targetBranch,
        body: prBody
      });

      console.log("Created PR:", pr.html_url);

      return {
        ...event,
        prUrl: pr.html_url,
        prNumber: pr.number
      };
    } catch (error) {
      console.error("Error creating pull request:", {
        error: error instanceof Error ? error.message : String(error),
        branch: branchName,
        base: event.targetBranch,
      });
      
      // Check for duplicate PR by looking at error details
      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();
        if (errorMsg.includes("validation failed") || 
            errorMsg.includes("pull request already exists") ||
            errorMsg.includes("a pull request already exists")) {
          throw new Error(`Failed to create PR: A pull request already exists for ${branchName}`);
        }
      }
      
      throw new Error("Failed to create pull request");
    }
  } catch (error) {
    console.error("Error in PRCreator:", {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  } finally {
    // Clean up working directory
    if (workdir && fs.existsSync(workdir)) {
      try {
        fs.rmSync(workdir, { recursive: true, force: true });
        console.log("Cleaned up working directory");
      } catch (cleanupError) {
        console.warn("Failed to clean up working directory:", {
          error: cleanupError instanceof Error ? cleanupError.message : String(cleanupError),
          workdir,
        });
      }
    }
  }
};
