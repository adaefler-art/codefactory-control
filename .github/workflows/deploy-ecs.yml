name: Deploy AFU-9 to ECS

# ============================================================================
# CANONICAL ECS APPLICATION DEPLOYMENT WORKFLOW
# ============================================================================
# Purpose: Build and deploy application Docker images to ECS
# When to use: Code changes, dependency updates, application configuration
# When NOT to use: Infrastructure changes (use deploy-cdk-stack.yml instead)
#
# Environments:
# - Staging: Auto-deploys on push to main branch
# - Production: Manual workflow_dispatch only
# ============================================================================

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - production
          - staging
        default: production
  push:
    branches:
      - main
    paths:
      - "control-center/**"
      - "mcp-servers/**"
      - ".github/workflows/deploy-ecs.yml"

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-ecs-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'staging' }}
  cancel-in-progress: false

env:
  AWS_REGION: eu-central-1
  ECS_CLUSTER: afu9-cluster
  DEPLOY_ENV: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'staging' }}

jobs:
  build-and-deploy:
    name: Build and Deploy to ECS
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Guard AWS_DEPLOY_ROLE_ARN
        run: |
          if [ -z "${{ secrets.AWS_DEPLOY_ROLE_ARN }}" ]; then
            echo "âŒ AWS_DEPLOY_ROLE_ARN is missing (secret is empty or undefined)" >&2
            exit 1
          fi

      - name: Set deployment variables
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_ENV="${{ env.DEPLOY_ENV }}"

          if [ "$DEPLOY_ENV" != "production" ] && [ "$DEPLOY_ENV" != "staging" ]; then
            echo "Unsupported environment: $DEPLOY_ENV" >&2
            exit 1
          fi

          if [ "$DEPLOY_ENV" = "production" ]; then
            TAG_PREFIX="prod"
            ECS_SERVICE="afu9-control-center-prod"
            ENV_LABEL="Production"
          else
            TAG_PREFIX="stage"
            ECS_SERVICE="afu9-control-center-stage"
            ENV_LABEL="Staging"
          fi

          echo "deploy_env=$DEPLOY_ENV" >> "$GITHUB_OUTPUT"
          echo "tag_prefix=$TAG_PREFIX" >> "$GITHUB_OUTPUT"
          echo "ecs_service=$ECS_SERVICE" >> "$GITHUB_OUTPUT"
          echo "env_label=$ENV_LABEL" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS OIDC Authentication
        shell: bash
        run: |
          set -euo pipefail
          echo "========================================="
          echo "Verifying AWS OIDC Authentication"
          echo "========================================="
          aws sts get-caller-identity
          echo "âœ… AWS authentication successful"

      - name: Install database client tooling
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install root dependencies
        shell: bash
        run: |
          set -euo pipefail
          npm ci

      - name: Validate secrets in AWS Secrets Manager
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ” Validating secrets before deployment..."
          npm run validate-secrets
          echo "âœ… All secrets validated successfully"

      - name: Resolve database connection string
        id: db-connection
        env:
          DEPLOY_ENV: ${{ steps.vars.outputs.deploy_env }}
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_NAME: ${{ vars.DB_SECRET_NAME }}
          PROD_DB_SECRET_NAME: ${{ vars.PROD_DB_SECRET_NAME }}
          STAGE_DB_SECRET_NAME: ${{ vars.STAGE_DB_SECRET_NAME }}
        shell: bash
        run: |
          set -euo pipefail

          DEFAULT_SECRET="afu9/database/master"
          SECRET_NAME="${DB_SECRET_NAME:-}"

          if [ "$DEPLOY_ENV" = "production" ] && [ -n "${PROD_DB_SECRET_NAME:-}" ]; then
            SECRET_NAME="$PROD_DB_SECRET_NAME"
          elif [ "$DEPLOY_ENV" = "staging" ] && [ -n "${STAGE_DB_SECRET_NAME:-}" ]; then
            SECRET_NAME="$STAGE_DB_SECRET_NAME"
          fi

          if [ -z "${SECRET_NAME:-}" ]; then
            SECRET_NAME="$DEFAULT_SECRET"
          fi

          echo "Using database secret: $SECRET_NAME"

          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_NAME" \
            --region "$AWS_REGION" \
            --query SecretString \
            --output text)

          if [ -z "$SECRET_JSON" ] || [ "$SECRET_JSON" = "None" ]; then
            echo "âŒ Failed to retrieve database secret" >&2
            exit 1
          fi

          # Accept "database" (preferred) and "dbname" (fallback)
          DATABASE_URL=$(echo "$SECRET_JSON" | jq -r '"postgresql://\(.username):\(.password)@\(.host):\(.port)/\(.database // .dbname)"')

          if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "null" ]; then
            echo "âŒ Could not construct DATABASE_URL from secret (expected keys: username, password, host, port, database/dbname)" >&2
            exit 1
          fi

          echo "::add-mask::$DATABASE_URL"
          echo "database_url=$DATABASE_URL" >> "$GITHUB_OUTPUT"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get ECR repository URIs
        id: ecr-uris
        shell: bash
        run: |
          set -euo pipefail
          echo "control_center=$(aws ecr describe-repositories --repository-names afu9/control-center --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_github=$(aws ecr describe-repositories --repository-names afu9/mcp-github --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_deploy=$(aws ecr describe-repositories --repository-names afu9/mcp-deploy --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_observability=$(aws ecr describe-repositories --repository-names afu9/mcp-observability --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"

      - name: Generate image tags
        id: image-tags
        shell: bash
        run: |
          set -euo pipefail
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT"

      - name: Build and push Control Center
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./control-center/Dockerfile
          push: true
          build-args: |
            BUILD_VERSION=0.4.0
            BUILD_COMMIT_HASH=${{ steps.image-tags.outputs.short_sha }}
            BUILD_ENV=${{ steps.vars.outputs.deploy_env }}
          tags: |
            ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.vars.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP GitHub Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/github/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.vars.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP Deploy Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/deploy/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.vars.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP Observability Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/observability/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.vars.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create new task definition with environment tags
        id: task-def
        shell: bash
        run: |
          set -euo pipefail
          echo "Creating new task definition for ${{ steps.vars.outputs.env_label }} with env-tagged images..."

          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ steps.vars.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "Current task definition: $TASK_DEF_ARN"

          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query 'taskDefinition' > task-def.json

          jq --arg cc_image "${{ steps.ecr-uris.outputs.control_center }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg gh_image "${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg dp_image "${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg ob_image "${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             '.containerDefinitions |= map(
               if .name == "control-center" then .image = $cc_image
               elif .name == "mcp-github" then .image = $gh_image
               elif .name == "mcp-deploy" then .image = $dp_image
               elif .name == "mcp-observability" then .image = $ob_image
               else . end
             ) |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
             task-def.json > new-task-def.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --region "${{ env.AWS_REGION }}" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> "$GITHUB_OUTPUT"
          echo "New task definition: $NEW_TASK_DEF_ARN"

      - name: Run database migrations (gate)
        id: migrate
        env:
          DATABASE_URL: ${{ steps.db-connection.outputs.database_url }}
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ—ï¸ Running database migrations for ${{ steps.vars.outputs.env_label }}..."

          # Reuse the service's awsvpc network configuration
          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ steps.vars.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json > awsvpc.json

          SUBNETS=$(jq -r '.subnets | join(",")' awsvpc.json)
          SGS=$(jq -r '.securityGroups | join(",")' awsvpc.json)
          ASSIGN_PUBLIC_IP=$(jq -r '.assignPublicIp // "DISABLED"' awsvpc.json)

          if [ -z "${SUBNETS:-}" ] || [ -z "${SGS:-}" ]; then
            echo "âŒ Could not determine VPC networking from ECS service" >&2
            cat awsvpc.json >&2 || true
            exit 1
          fi

          # Run a one-off Fargate task using the NEW task definition and override the command
          OVERRIDES_JSON=$(jq -nc --arg db "$DATABASE_URL" '{
            containerOverrides: [{
              name: "control-center",
              command: ["sh","-lc","npm run db:migrate"],
              environment: [{ name: "DATABASE_URL", value: $db }]
            }]
          }')

          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --launch-type FARGATE \
            --task-definition "${{ steps.task-def.outputs.new_task_def_arn }}" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SGS],assignPublicIp=$ASSIGN_PUBLIC_IP}" \
            --overrides "$OVERRIDES_JSON" \
            --region "${{ env.AWS_REGION }}" \
            --query 'tasks[0].taskArn' \
            --output text)

          if [ -z "${TASK_ARN:-}" ] || [ "$TASK_ARN" = "None" ]; then
            echo "âŒ Failed to start migration task" >&2
            exit 1
          fi

          echo "Migration task: $TASK_ARN"
          echo "task_arn=$TASK_ARN" >> "$GITHUB_OUTPUT"

          aws ecs wait tasks-stopped \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --region "${{ env.AWS_REGION }}"

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query 'tasks[0].containers[?name==`control-center`].exitCode | [0]' \
            --output text)

          echo "Migration exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Database migrations failed" >&2
            exit 1
          fi

          echo "âœ… Database migrations applied"

      - name: Check deployment verdict gate
        env:
          DEPLOYMENT_VERDICT: ${{ vars.DEPLOYMENT_VERDICT }}
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ” Checking deployment verdict gate..."
          echo "Issue B3: No deployment without GREEN verdict"
          echo ""
          VERDICT="${DEPLOYMENT_VERDICT:-GREEN}"
          node scripts/check-deployment-gate.js "$VERDICT"
          echo ""
          echo "âœ… Verdict gate check passed - proceeding with deployment"

      - name: Update ECS service
        shell: bash
        run: |
          set -euo pipefail
          echo "Updating ECS service with new task definition..."
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ steps.vars.outputs.ecs_service }}" \
            --task-definition "${{ steps.task-def.outputs.new_task_def_arn }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Wait for service stability
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for service to reach stable state..."
          aws ecs wait services-stable \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ steps.vars.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Get service status
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "Service deployment status:"
          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ steps.vars.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'services[0].{status:status,runningCount:runningCount,desiredCount:desiredCount,deployments:deployments}' \
            --output table

      - name: Get ALB DNS for verification
        id: alb-dns
        shell: bash
        run: |
          set -euo pipefail
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name Afu9NetworkStack \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [ -z "$ALB_DNS" ]; then
            echo "Warning: Could not fetch ALB DNS from CloudFormation, trying alternative method..."
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --names afu9-alb \
              --query 'LoadBalancers[0].DNSName' \
              --output text 2>/dev/null || echo "")
          fi

          echo "alb_dns=${ALB_DNS}" >> "$GITHUB_OUTPUT"
          echo "ALB DNS: ${ALB_DNS}"

      - name: Run post-deployment verification
        shell: bash
        run: |
          set -euo pipefail
          echo "Running automated post-deployment verification..."
          chmod +x ./scripts/post-deploy-verification.sh
          ./scripts/post-deploy-verification.sh \
            "${{ steps.vars.outputs.tag_prefix }}" \
            "${{ env.ECS_CLUSTER }}" \
            "${{ steps.vars.outputs.ecs_service }}" \
            "${{ steps.alb-dns.outputs.alb_dns }}"

      - name: Deployment summary
        shell: bash
        run: |
          set -euo pipefail
          {
            echo "## Deployment Summary"
            echo ""
            echo "âœ… **Deployment completed successfully**"
            echo "Environment: ${{ steps.vars.outputs.env_label }}"
            echo ""
            echo "### Images deployed:"
            echo "- Control Center: \`${{ steps.ecr-uris.outputs.control_center }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP GitHub: \`${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP Deploy: \`${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP Observability: \`${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.vars.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo ""
            echo "### ECS Configuration:"
            echo "- Cluster: \`${{ env.ECS_CLUSTER }}\`"
            echo "- Service: \`${{ steps.vars.outputs.ecs_service }}\`"
            echo "- Region: \`${{ env.AWS_REGION }}\`"
            echo "- Task Definition: \`${{ steps.task-def.outputs.new_task_def_arn }}\`"
            echo "- ALB DNS: ${{ steps.alb-dns.outputs.alb_dns }}"
            echo ""
            echo "### Rollback Information:"
            echo "- Git SHA: \`${{ github.sha }}\`"
            echo "- Short SHA: \`${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- Environment: ${{ steps.vars.outputs.env_label }}"
          } >> "$GITHUB_STEP_SUMMARY"
