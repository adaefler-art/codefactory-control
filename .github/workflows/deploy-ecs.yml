name: Deploy AFU-9 to ECS

# ============================================================================
# CANONICAL ECS APPLICATION DEPLOYMENT WORKFLOW
# ============================================================================
# Purpose: Build and deploy application Docker images to ECS
# When to use: Code changes, dependency updates, application configuration
# When NOT to use: Infrastructure changes (use deploy-cdk-stack.yml instead)
#
# Environments:
# - Staging: Auto-deploys on push to main branch
# - Production: Manual workflow_dispatch only
# ============================================================================

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - production
          - staging
        default: production
  push:
    branches:
      - main
    paths:
      - "control-center/**"
      - "mcp-servers/**"
      - ".github/workflows/deploy-ecs.yml"

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-ecs-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'staging' }}
  cancel-in-progress: false

env:
  AWS_REGION: eu-central-1
  DEPLOY_ENV: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'staging' }}

jobs:
  build-and-deploy:
    name: Build and Deploy to ECS
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Guard AWS_DEPLOY_ROLE_ARN
        run: |
          if [ -z "${{ secrets.AWS_DEPLOY_ROLE_ARN }}" ]; then
            echo "âŒ AWS_DEPLOY_ROLE_ARN is missing (secret is empty or undefined)" >&2
            exit 1
          fi

      - name: Resolve deploy target (guarded)
        id: target
        shell: pwsh
        run: |
          $deployEnv = "${{ env.DEPLOY_ENV }}"
          $stagingCluster = "${{ vars.STAGING_ECS_CLUSTER }}"
          if (-not $stagingCluster) { $stagingCluster = 'afu9-cluster-staging' }

          if ($deployEnv -ne 'production' -and $deployEnv -ne 'staging') {
            Write-Error "Unsupported DEPLOY_ENV: $deployEnv"; exit 1
          }

          if ($deployEnv -eq 'production') {
            $tagPrefix = 'prod'
            $ecsService = 'afu9-control-center'
            $ecsCluster = 'afu9-cluster'
            $envLabel = 'Production'
            $readyHost = 'afu-9.com'
          } else {
            $tagPrefix = 'stage'
            $ecsService = 'afu9-control-center-staging'
            $ecsCluster = $stagingCluster
            $envLabel = 'Staging'
            $readyHost = 'stage.afu-9.com'
          }

          if ($deployEnv -eq 'staging' -and $ecsService -eq 'afu9-control-center') {
            Write-Error "Staging deployment would target production service (afu9-control-center)."; exit 1
          }
          if ($deployEnv -eq 'staging' -and ($ecsService -notmatch 'staging')) {
            Write-Error "Staging deployment must use a staging service name. Got: $ecsService"; exit 1
          }
          if ($deployEnv -eq 'production' -and ($ecsService -match 'staging')) {
            Write-Error "Production deployment must not target a staging service name. Got: $ecsService"; exit 1
          }

          "deploy_env=$deployEnv" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "tag_prefix=$tagPrefix" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "ecs_service=$ecsService" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "env_label=$envLabel" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "ecs_cluster=$ecsCluster" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "ready_host=$readyHost" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Enable AWS CLI AccessDenied logging
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/aws-wrap-bin

          REAL_AWS_PATH="$(command -v aws || true)"
          if [ -z "$REAL_AWS_PATH" ] || [ ! -x "$REAL_AWS_PATH" ]; then
            echo "aws wrapper: cannot find real aws binary on PATH" >&2
            exit 127
          fi
          echo "Real aws: $REAL_AWS_PATH"

          printf '%s\n' \
            '#!/usr/bin/env bash' \
            'set -euo pipefail' \
            '' \
            "REAL_AWS=\"$REAL_AWS_PATH\"" \
            '' \
            'out_log="$(mktemp)"' \
            'err_log="$(mktemp)"' \
            'trap '\''rm -f "$out_log" "$err_log"'\'' EXIT' \
            '' \
            '"$REAL_AWS" "$@" > >(tee "$out_log") 2> >(tee "$err_log" >&2)' \
            'rc=$?' \
            '' \
            'if grep -q -E "AccessDenied|not authorized|is not authorized" "$err_log"; then' \
            '  echo "=== AccessDenied (stderr) ===" >&2' \
            '  grep -E "AccessDenied|not authorized|is not authorized" "$err_log" >&2 || true' \
            '  echo "=============================" >&2' \
            'fi' \
            '' \
            'exit $rc' \
            > /tmp/aws-wrap-bin/aws

          chmod +x /tmp/aws-wrap-bin/aws
          echo "/tmp/aws-wrap-bin" >> "$GITHUB_PATH"

      - name: Verify AWS OIDC Authentication
        shell: bash
        run: |
          set -euo pipefail
          echo "========================================="
          echo "Verifying AWS OIDC Authentication"
          echo "========================================="
          aws sts get-caller-identity
          echo "âœ… AWS authentication successful"

      - name: Diagnose deploy role permissions (optional)
        shell: bash
        env:
          DEBUG_IAM_ROLE_ARN: ${{ secrets.DEBUG_IAM_ROLE_ARN }}
        run: |
          set -euo pipefail
          if [ -z "${DEBUG_IAM_ROLE_ARN:-}" ]; then
            echo "Skipping IAM diagnostics: DEBUG_IAM_ROLE_ARN not set."
            exit 0
          fi

          echo "Inspecting role: ${DEBUG_IAM_ROLE_ARN}"
          ROLE_NAME=$(basename "$DEBUG_IAM_ROLE_ARN")
          aws iam get-role --role-name "$ROLE_NAME" --query '{RoleArn:Role.Arn,PermissionsBoundary:Role.PermissionsBoundary}' --output json || true

          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws iam simulate-principal-policy \
            --policy-source-arn "$DEBUG_IAM_ROLE_ARN" \
            --action-names ecs:DescribeTaskDefinition ecs:RegisterTaskDefinition \
            --resource-arns "arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:task-definition/*" \
            --output json || true

      - name: Install database client tooling
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install root dependencies
        shell: bash
        run: |
          set -euo pipefail
          npm ci

      - name: Validate secrets in AWS Secrets Manager
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ” Validating secrets before deployment..."
          npm run validate-secrets
          echo "âœ… All secrets validated successfully"

      - name: Resolve database connection string
        id: db-connection
        env:
          DEPLOY_ENV: ${{ steps.target.outputs.deploy_env }}
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_NAME: ${{ vars.DB_SECRET_NAME }}
          PROD_DB_SECRET_NAME: ${{ vars.PROD_DB_SECRET_NAME }}
          STAGE_DB_SECRET_NAME: ${{ vars.STAGE_DB_SECRET_NAME }}
        shell: bash
        run: |
          set -euo pipefail

          DEFAULT_SECRET="afu9/database/master"
          SECRET_NAME="${DB_SECRET_NAME:-}"

          if [ "$DEPLOY_ENV" = "production" ] && [ -n "${PROD_DB_SECRET_NAME:-}" ]; then
            SECRET_NAME="$PROD_DB_SECRET_NAME"
          elif [ "$DEPLOY_ENV" = "staging" ] && [ -n "${STAGE_DB_SECRET_NAME:-}" ]; then
            SECRET_NAME="$STAGE_DB_SECRET_NAME"
          fi

          if [ -z "${SECRET_NAME:-}" ]; then
            SECRET_NAME="$DEFAULT_SECRET"
          fi

          echo "Using database secret: $SECRET_NAME"

          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_NAME" \
            --region "$AWS_REGION" \
            --query SecretString \
            --output text)

          if [ -z "$SECRET_JSON" ] || [ "$SECRET_JSON" = "None" ]; then
            echo "âŒ Failed to retrieve database secret" >&2
            exit 1
          fi

          # Accept "database" (preferred) and "dbname" (fallback)
          DATABASE_URL=$(echo "$SECRET_JSON" | jq -r '"postgresql://\(.username):\(.password)@\(.host):\(.port)/\(.database // .dbname)"')

          if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "null" ]; then
            echo "âŒ Could not construct DATABASE_URL from secret (expected keys: username, password, host, port, database/dbname)" >&2
            exit 1
          fi

          echo "::add-mask::$DATABASE_URL"
          echo "database_url=$DATABASE_URL" >> "$GITHUB_OUTPUT"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get ECR repository URIs
        id: ecr-uris
        shell: bash
        run: |
          set -euo pipefail
          echo "control_center=$(aws ecr describe-repositories --repository-names afu9/control-center --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_github=$(aws ecr describe-repositories --repository-names afu9/mcp-github --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_deploy=$(aws ecr describe-repositories --repository-names afu9/mcp-deploy --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"
          echo "mcp_observability=$(aws ecr describe-repositories --repository-names afu9/mcp-observability --query 'repositories[0].repositoryUri' --output text)" >> "$GITHUB_OUTPUT"

      - name: Generate image tags
        id: image-tags
        shell: bash
        run: |
          set -euo pipefail
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT"

      - name: Build and push Control Center
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./control-center/Dockerfile
          push: true
          build-args: |
            BUILD_VERSION=0.4.0
            BUILD_COMMIT_HASH=${{ steps.image-tags.outputs.short_sha }}
            BUILD_ENV=${{ steps.target.outputs.deploy_env }}
          tags: |
              ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
              ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
              ${{ steps.ecr-uris.outputs.control_center }}:${{ steps.target.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP GitHub Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/github/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.target.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP Deploy Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/deploy/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.target.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MCP Observability Server
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-servers
          file: ./mcp-servers/observability/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.timestamp }}
            ${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.target.outputs.tag_prefix }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create new task definition with environment tags
        id: task-def
        shell: bash
        run: |
          set -euo pipefail
          echo "Creating new task definition for ${{ steps.target.outputs.env_label }} with env-tagged images..."

          SERVICE_JSON=$(aws ecs describe-services \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --services "${{ steps.target.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --output json)

          if echo "$SERVICE_JSON" | jq -e '.failures | length > 0' >/dev/null; then
            echo "âŒ ECS describe-services reported failures:" >&2
            echo "$SERVICE_JSON" | jq '.failures' >&2
            exit 1
          fi

          if [ "$(echo "$SERVICE_JSON" | jq -r '.services | length')" = "0" ]; then
            echo "âŒ ECS service ${{ steps.target.outputs.ecs_service }} not found in cluster ${{ steps.target.outputs.ecs_cluster }}" >&2
            echo "Listing services for debugging:" >&2
            aws ecs list-services --cluster "${{ steps.target.outputs.ecs_cluster }}" --region "${{ env.AWS_REGION }}" --output json >&2
            exit 1
          fi

          TASK_DEF_ARN=$(echo "$SERVICE_JSON" | jq -r '.services[0].taskDefinition // ""')

          if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" = "None" ]; then
            echo "âŒ Task definition is empty for service ${{ steps.target.outputs.ecs_service }}" >&2
            echo "$SERVICE_JSON" | jq '.services[0]' >&2
            exit 1
          fi

          echo "Current task definition: $TASK_DEF_ARN"

          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query 'taskDefinition' > task-def.json

           jq --arg cc_image "${{ steps.ecr-uris.outputs.control_center }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg gh_image "${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg dp_image "${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             --arg ob_image "${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}" \
             '.containerDefinitions |= map(
               if .name == "control-center" then .image = $cc_image
               elif .name == "mcp-github" then .image = $gh_image
               elif .name == "mcp-deploy" then .image = $dp_image
               elif .name == "mcp-observability" then .image = $ob_image
               else . end
             ) |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
             task-def.json > new-task-def.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --region "${{ env.AWS_REGION }}" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> "$GITHUB_OUTPUT"
          echo "New task definition: $NEW_TASK_DEF_ARN"

      - name: Run database migrations (gate)
        id: migrate
        env:
          DATABASE_URL: ${{ steps.db-connection.outputs.database_url }}
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ—ï¸ Running database migrations for ${{ steps.target.outputs.env_label }}..."

          # Reuse the service's awsvpc network configuration
          aws ecs describe-services \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --services "${{ steps.target.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json > awsvpc.json

          SUBNETS=$(jq -r '.subnets | join(",")' awsvpc.json)
          SGS=$(jq -r '.securityGroups | join(",")' awsvpc.json)
          ASSIGN_PUBLIC_IP=$(jq -r '.assignPublicIp // "DISABLED"' awsvpc.json)

          if [ -z "${SUBNETS:-}" ] || [ -z "${SGS:-}" ]; then
            echo "âŒ Could not determine VPC networking from ECS service" >&2
            cat awsvpc.json >&2 || true
            exit 1
          fi

          # Run a one-off Fargate task using the NEW task definition and override the command
          OVERRIDES_JSON=$(jq -nc --arg db "$DATABASE_URL" '{
            containerOverrides: [{
              name: "control-center",
              command: ["sh","-lc","npm run db:migrate"],
              environment: [{ name: "DATABASE_URL", value: $db }]
            }]
          }')

          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --launch-type FARGATE \
            --task-definition "${{ steps.task-def.outputs.new_task_def_arn }}" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SGS],assignPublicIp=$ASSIGN_PUBLIC_IP}" \
            --overrides "$OVERRIDES_JSON" \
            --region "${{ env.AWS_REGION }}" \
            --query 'tasks[0].taskArn' \
            --output text)

          if [ -z "${TASK_ARN:-}" ] || [ "$TASK_ARN" = "None" ]; then
            echo "âŒ Failed to start migration task" >&2
            exit 1
          fi

          echo "Migration task: $TASK_ARN"
          echo "task_arn=$TASK_ARN" >> "$GITHUB_OUTPUT"

          aws ecs wait tasks-stopped \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --tasks "$TASK_ARN" \
            --region "${{ env.AWS_REGION }}"

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --tasks "$TASK_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query 'tasks[0].containers[?name==`control-center`].exitCode | [0]' \
            --output text)

          echo "Migration exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Database migrations failed" >&2
            exit 1
          fi

          echo "âœ… Database migrations applied"

      - name: Check deployment verdict gate
        env:
          DEPLOYMENT_VERDICT: ${{ vars.DEPLOYMENT_VERDICT }}
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ” Checking deployment verdict gate..."
          echo "Issue B3: No deployment without GREEN verdict"
          echo ""
          VERDICT="${DEPLOYMENT_VERDICT:-GREEN}"
          node scripts/check-deployment-gate.js "$VERDICT"
          echo ""
          echo "âœ… Verdict gate check passed - proceeding with deployment"

      - name: Update ECS service
        shell: bash
        run: |
          set -euo pipefail
          echo "Updating ECS service with new task definition..."
          aws ecs update-service \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --service "${{ steps.target.outputs.ecs_service }}" \
            --task-definition "${{ steps.task-def.outputs.new_task_def_arn }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Wait for ECS service stable
        shell: pwsh
        run: |
          aws ecs wait services-stable \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --services "${{ steps.target.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Get service status
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "Service deployment status:"
          aws ecs describe-services \
            --cluster "${{ steps.target.outputs.ecs_cluster }}" \
            --services "${{ steps.target.outputs.ecs_service }}" \
            --region "${{ env.AWS_REGION }}" \
            --query 'services[0].{status:status,runningCount:runningCount,desiredCount:desiredCount,deployments:deployments}' \
            --output table

      - name: Post-deploy readiness (/api/ready)
        shell: pwsh
        env:
          ALB_DNS_NAME: ${{ steps.alb-dns.outputs.alb_dns_name }}
          READY_HOST: ${{ steps.target.outputs.ready_host }}
        run: |
          $target = if ($env:ALB_DNS_NAME) { $env:ALB_DNS_NAME } else { $env:READY_HOST }
          $uri = "https://$target/api/ready"
          $host = $env:READY_HOST
          Write-Host "Probing readiness at $uri (Host: $host)"
          for ($i = 1; $i -le 30; $i++) {
            try {
              $resp = Invoke-WebRequest -Uri $uri -Headers @{ Host = $host } -UseBasicParsing -TimeoutSec 10
              if ($resp.StatusCode -eq 200) { Write-Host "Ready (attempt $i)"; break }
            } catch {}
            if ($i -eq 30) { Write-Error "Readiness probe failed after $i attempts"; exit 1 }
            Start-Sleep -Seconds 5
          }

      - name: Resolve ALB DNS
        id: resolve_alb
        shell: pwsh
        run: |
          # $env:GITHUB_OUTPUT exists in GitHub Actions; locally it can be null. Write to it only when present.
          $writeOutput = $false
          if ($env:GITHUB_OUTPUT) { $writeOutput = $true }

          $cluster = "${{ steps.target.outputs.ecs_cluster }}"
          $service = "${{ steps.target.outputs.ecs_service }}"

          # 1) Describe service to get target group ARN
          $svcJson = aws ecs describe-services --cluster $cluster --services $service --region "${{ env.AWS_REGION }}" --output json
          $tgArn = ($svcJson | ConvertFrom-Json).services[0].loadBalancers[0].targetGroupArn
          if (-not $tgArn) {
            Write-Error "No loadBalancers attached to service $service in cluster $cluster"; exit 1
          }

          # 2) Describe target group to get ALB ARN
          $tgJson = aws elbv2 describe-target-groups --target-group-arns $tgArn --region "${{ env.AWS_REGION }}" --output json
          $albArn = ($tgJson | ConvertFrom-Json).TargetGroups[0].LoadBalancerArns[0]
          if (-not $albArn) {
            Write-Error "No LoadBalancerArn found for target group $tgArn"; exit 1
          }

          # 3) Describe load balancer to get DNS name
          $albJson = aws elbv2 describe-load-balancers --load-balancer-arns $albArn --region "${{ env.AWS_REGION }}" --output json
          $albDns = ($albJson | ConvertFrom-Json).LoadBalancers[0].DNSName
          if (-not $albDns) {
            Write-Error "No DNSName found for ALB $albArn"; exit 1
          }

          if ($writeOutput) {
            "alb_dns=$albDns" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            Write-Host "alb_dns=$albDns"
          }

          Write-Host "Resolved ALB DNS: $albDns"

      - name: Run post-deployment verification
        shell: bash
        run: |
          set -euo pipefail
          echo "Running automated post-deployment verification..."
          chmod +x ./scripts/post-deploy-verification.sh
          ./scripts/post-deploy-verification.sh \
            "${{ steps.target.outputs.tag_prefix }}" \
            "${{ steps.target.outputs.ecs_cluster }}" \
            "${{ steps.target.outputs.ecs_service }}" \
              "${{ steps.alb-dns.outputs.alb_dns_name }}"

      - name: Deployment summary
        shell: bash
        run: |
          set -euo pipefail
          {
            echo "## Deployment Summary"
            echo ""
            echo "âœ… **Deployment completed successfully**"
            echo "Environment: ${{ steps.target.outputs.env_label }}"
            echo ""
            echo "### Images deployed:"
            echo "- Control Center: \`${{ steps.ecr-uris.outputs.control_center }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP GitHub: \`${{ steps.ecr-uris.outputs.mcp_github }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP Deploy: \`${{ steps.ecr-uris.outputs.mcp_deploy }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- MCP Observability: \`${{ steps.ecr-uris.outputs.mcp_observability }}:${{ steps.target.outputs.tag_prefix }}-${{ steps.image-tags.outputs.short_sha }}\`"
            echo ""
            echo "### ECS Configuration:"
            echo "- Cluster: \`${{ steps.target.outputs.ecs_cluster }}\`"
            echo "- Service: \`${{ steps.target.outputs.ecs_service }}\`"
            echo "- Region: \`${{ env.AWS_REGION }}\`"
            echo "- Task Definition: \`${{ steps.task-def.outputs.new_task_def_arn }}\`"
            echo "- ALB DNS: ${{ steps.alb-dns.outputs.alb_dns_name }}"
            echo ""
            echo "### Rollback Information:"
            echo "- Git SHA: \`${{ github.sha }}\`"
            echo "- Short SHA: \`${{ steps.image-tags.outputs.short_sha }}\`"
            echo "- Environment: ${{ steps.target.outputs.env_label }}"
          } >> "$GITHUB_STEP_SUMMARY"
